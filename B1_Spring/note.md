### 为什么需要spring
```text
spring是一个非常优秀的java框架，其目标是为了简化java企业级开发，spring出来已经十几年了，这期间也一直围绕着这个目标在进行，
像后面需要学习的springmvc、springboot、springcloud，这些技术也都是围绕着简化开发的目标在努力，到目前为止已经做的足够好了，
可以说spring除了不能帮助我们实现业务逻辑代码之外，其他的事情spring都尽量去帮我们简化了，使用spring可以帮助我们节约大量开发时间。
```


### 引入spring
```text
spring容器

spring容器的概念，容器这个名字起的相当好，容器可以放很多东西，
我们的程序启动的时候会创建spring容器，会给spring容器一个清单，清单中列出了需要创建的对象以及对象依赖关系，
spring容器会创建和组装好清单中的对象，然后将这些对象存放在spring容器中，当程序中需要使用的时候，可以到容器中查找获取，然后直接使用。

IOC：控制反转

使用者之前使用B对象的时候都需要自己去创建和组装，而现在这些创建和组装都交给spring容器去给完成了，
使用者只需要去spring容器中查找需要使用的对象就可以了；这个过程中B对象的创建和组装过程被反转了，
之前是使用者自己主动去控制的，现在交给spring容器去创建和组装了，对象的构建过程被反转了，所以叫做控制反转；
IOC是是面相对象编程中的一种设计原则，主要是为了降低系统代码的耦合度，让系统利于维护和扩展。

DI：依赖注入

依赖注入是spring容器中创建对象时给其设置依赖对象的方式，
比如给spring一个清单，清单中列出了需要创建B对象以及其他的一些对象（可能包含了B类型中需要依赖对象），
此时spring在创建B对象的时候，会看B对象需要依赖于哪些对象，然后去查找一下清单中有没有包含这些被依赖的对象，
如果有就去将其创建好，然后将其传递给B对象；可能B需要依赖于很多对象，
B创建之前完全不需要知道其他对象是否存在或者其他对象在哪里以及被他们是如何创建，
而spring容器会将B依赖对象主动创建好并将其注入到B中去，比如spring容器创建B的时候，
发现B需要依赖于A，那么spring容器在清单中找到A的定义并将其创建好之后，注入到B对象中
```


### Spring容器对象
```text
BeanFactory接口
ApplicationContext接口
ClassPathXmlApplicationContext类
AnnotationConfigApplicationContext类
```


### 注解
+ @Override 的理解
  + 就是一个注解，加在方法上，标注当前方法重写了父类的方法，当编译器编译代码的时候，会对@Override标注的方法进行验证，验证其父类中是否也有同样签名的方法，否则报错，通过这个注解是不是增强了代码的安全性。

+ 定义注解
  + @interface

+ 注解中定义参数
  + [public] 参数类型 参数名称1() [default 参数默认值];
```text
访问修饰符必须为public，不写默认为public
该元素的类型只能是基本数据类型、String、Class、枚举类型、注解类型（体现了注解的嵌套效果）以及上述类型的一位数组
该元素的名称一般定义为名词，如果注解中只有一个元素，请把名字起为value（后面使用会带来便利操作）
参数名称后面的()不是定义方法参数的地方，也不能在括号中定义任何参数，仅仅只是一个特殊的语法
default代表默认值，值必须和第2点定义的类型一致
如果没有默认值，代表后续使用注解时必须给该类型元素赋值
```

+ 指定注解的使用范围：@Target
+ 指定注解的保留策略：@Retention
+ @Inherit：实现类之间的注解继承
+ @Repeatable重复使用注解

+ 使用注解
+ 无参注解
+ 一个参数的注解